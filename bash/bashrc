# -*- sh -*-
### genehack .bashrc

# $Id$
# $URL$

## globals
if [ -f /etc/bashrc ]; then
    . /etc/bashrc
fi

## OS
if [ `uname` = 'Darwin' ]; then
    export OS_TYPE='darwin'
elif [ `uname` = 'FreeBSD' ]; then
    export OS_TYPE='freebsd'
else
    export OS_TYPE='linux'
fi

## $HOSTNAME 
if [ $OS_TYPE = 'darwin' -o $OS_TYPE = 'freebsd' ]; then
    export HOSTNAME=`hostname -s`
    export DOMAIN=`hostname | cut -f2- -d.`
    export FULL_HOSTNAME=`hostname`
    if [ $FULL_HOSTNAME = 'mactop.local' ]; then
        export FULL_HOSTNAME='mactop.ncbi.nlm.nih.gov'
        export DOMAIN='ncbi.nlm.nih.gov'
    fi
else
    export HOSTNAME=`hostname`
    export DOMAIN=`hostname -d`
    export FULL_HOSTNAME=`hostname -f`
fi

## BASH COMPLETION
if [ -e /etc/profile.d/bash-completion ]; then
    . /etc/profile.d/bash-completion
elif [ -e /etc/profile.d/complete.bash ]; then
    . /etc/profile.d/complete.bash
fi

## ALIASES
if [ -e $HOME/.aliases ]; then
    . $HOME/.aliases
fi

## EDITORS
### FIXME should really get things to where these can be set to emacs...
export EDITOR=vim
export VISUAL=vim

## FETCHMAIL
#  if we're on a mail reading machine, set FETCHMAILHOME
if [ -e $HOME/etc/fetchmail/fetchmailrc ]; then
    export FETCHMAILHOME=$HOME/etc/fetchmail
fi

## FUNCTIONS
# ganked from <http://www.enigmacurry.com/2007/05/24/multi-tty-emacs-on-gentoo-and-ubuntu/>
SERVERNAME=genehack
start_emacs () {
    #Attempt to connect to an existing server
    emacsclient -s $SERVERNAME $*
    if [ $? -ne 0 ]; then
    #Start a new emacs server and connect
        preload_emacs $SERVERNAME 0
        emacsclient -s $SERVERNAME $*
    fi
}


## KEYCHAIN 
`which keychain 2>&1 >/dev/null`
if [ $? = 0 ]; then
    if [ -e ~/.ssh/id_dsa ]; then
        keychain -q ~/.ssh/id_dsa 2>/dev/null
    fi
    if [ -e ~/.keychain/${HOSTNAME}-sh ]; then
        . ~/.keychain/${HOSTNAME}-sh > /dev/null
    fi
fi


## PATHS
# logic:
# a) there's a list of common places where software may be
#
# b) for each, there may be 'bin', 'man', and 'sbin' dirs that need to
#    be added to various PATH variables
#
# c) but if something doesn't exist, we don't want to pollute the
#    environment with it
#
# d) because we're going to be adding things at the front of the
#    various *PATH directories, the outer loop needs to be in reverse
#    order

# taken from <http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_11_02.html>
if [ $OS_TYPE = 'darwin' ]; then
    EGREP=/usr/bin/egrep
else
    EGREP=/bin/egrep
fi

pathmunge () {
    if [ ! $CPAN2RPM ]; then
        for DIR in bin sbin ; do
            if [ -e $1/$DIR ]; then
                if ! echo $PATH | $EGREP -q "(^|:)$1/$DIR($|:)" ; then
                    if [ "$2" = "after" ] ; then
                        PATH=$PATH:$1/$DIR
                    else
                        PATH=$1/$DIR:$PATH
                    fi
                fi
            fi
        done
        if [ -e $1/man ]; then
            if ! echo $MANPATH | $EGREP -q "(^|:)$1/man($|:)" ; then
                if [ "$2" = "after" ]; then
                    MANPATH=$MANPATH:$1/man
                else
                    MANPATH=$1/man:$MANPATH
                fi
            fi
        fi
    fi
}


LOCATIONS="/usr/local /opt/perl-5.8.8 /opt/local $HOME/local $HOME"
for LOC in $LOCATIONS ; do
    pathmunge $LOC
done

unset pathmunge

## SET PROMPT
setprompt() {
  local load etc

  P1="{$(color yellow)\T$(color off)}"
  P2="($(color green)\h$(color off))"

  if [ -e /proc/loadavg ]; then
      read load etc < /proc/loadavg
  else
      load=""
  fi
  
  P3=""
  if [ $load ]; then 
      if [ ${load%.*} -ge 2 ]; then
	  P3="[$(color red white)$load$(color off)]"
      else
	  P3="[$(color ltblue)$load$(color off)]"
      fi
  fi
    
  P4="-$(color red)\$?$(color off)-"

  P5="<$(color yellow)\w$(color off)>"

  PS1="\n$P1 $P2 $P3 $P4\n$P5 \$ "
}

 if [ $OS_TYPE = 'darwin' ]; then
     setprompt
 else
     PROMPT_COMMAND=setprompt
fi

## SHELL OPTIONS
export HISTFILESIZE=1000000000
export HISTIGNORE="&:ls:[bf]g:ext"
export HISTSIZE=1000000
export LC_ALL=POSIX
shopt -s cdspell
shopt -s dotglob
shopt -s no_empty_cmd_completion

